<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_toaster</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Creates player variables
grav = .6;
hsp = 0;
vsp = 0;
jumpSpeed = 7;
moveSpeed = 4;
afterLaunch = 1;
isLaunching = false;

heat = 0;
imagestart = 8;
imageend = 23;
alarmOn = false;
last_move = 0;

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// variables for toaster slider
in_slow_motion = false;
time_toasting = 0;

//constant variables
time_toasting_max = 1500 * 1500;
sprite_bar_height = 48;
sprite_bar_width = 800;
sprite_indicator_size = 32;
sprite_element_size = 64;
barX = 100;
barY = 50;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// initialize global time progression
global.deltaT = 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>room_goto(1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Fire Toast

//If not launching, heat decrements
if(heat &gt; 0 &amp;&amp; !isLaunching){
    heat -= .05;
}
//If on the ground and not launching, heat decrements faster
if(place_meeting(x, y + 1, obj_wall)) {
    if(heat &gt; 0 &amp;&amp; !isLaunching){
        heat -= .3;
    }
}
//If left mouse button is pressed and heat is below 15, start the timer for firing.
if(mouse_check_button_pressed(mb_left) &amp;&amp; heat &lt; 15) {
    time = current_time;
    in_slow_motion = true;
    time_toasting = 0;
    isLaunching = true;
    
    global.deltaT = .05;
    
    bar_time = 1500 * power(.95, heat); //Controls the speed of the bar based amount of heat
    time_toasting_max = bar_time * bar_time;
}

if(mouse_check_button(mb_left) &amp;&amp; isLaunching){
    image_angle = -darctan2(mouse_y - y, mouse_x - x) - 90;

    time_toasting = (current_time - time) * (current_time - time);
    
    if(current_time - time &gt; bar_time){
        isLaunching = false;
        global.deltaT = 1;
        in_slow_motion = false;
        newTime = current_time - time;
        
        audio_play_sound(snd_brun,1,false);
        
        heat = 20;
        burntToast = instance_create(x + (60 * ((mouse_x - x) / x)), y + (60 * ((mouse_y - y) / y)), obj_burntToast);
        burntToast.direction = point_direction(x, y, mouse_x, mouse_y);
        burntToast.image_angle = point_direction(x, y, mouse_x, mouse_y);
        burntToast.speed = 0;
    }
}

if(mouse_check_button_released(mb_left) &amp;&amp; isLaunching) {
    isLaunching = false;
    global.deltaT = 1;
    in_slow_motion = false;
    newTime = current_time - time;
    
    heat += newTime*5/bar_time;
    
    if(newTime &gt; 1372*bar_time/1500) {
    
        audio_play_sound(snd_brun,1,false);
        
        burntToast = instance_create(x + (60 * ((mouse_x - x) / x)), y + (60 * ((mouse_y - y) / y)), obj_burntToast);
        burntToast.direction = point_direction(x, y, mouse_x, mouse_y);
        burntToast.image_angle = point_direction(x, y, mouse_x, mouse_y);
        burntToast.speed = 0;
    }
    else if(newTime &gt; 1297*bar_time/1500) {
        flameToast = instance_create(x, y, obj_flameToast);
        flameToast.direction = point_direction(x, y, mouse_x, mouse_y);
        flameToast.image_angle = point_direction(x, y, mouse_x, mouse_y);
        spd = 20;
        afterLaunch = 0;

        dist = sqrt( (x - mouse_x)*(x - mouse_x) + (y - mouse_y)*(y - mouse_y) );
        dx = (x - mouse_x) / dist;
        dy = (y - mouse_y) / dist;
        vsp = (spd * dy);
        hsp = (spd * dx);
        
        flameToast.vsp = spd * -dy;
        flameToast.hsp = spd * -dx;
        
        cooldown = current_time;
    }
            
    else if(newTime &gt; 1034*bar_time/1500) {
        toast = instance_create(x, y, obj_toast);
        toast.direction = point_direction(x, y, mouse_x, mouse_y);
        toast.image_angle = point_direction(x, y, mouse_x, mouse_y);
        spd = 14;
        afterLaunch = 0;
        
        dist = sqrt( (x - mouse_x)*(x - mouse_x) + (y - mouse_y)*(y - mouse_y) );
        dx = (x - mouse_x) / dist;
        dy = (y - mouse_y) / dist;
        vsp = (spd * dy);
        hsp = (spd * dx);
        
        toast.vsp = spd * -dy;
        toast.hsp = spd * -dx;

        cooldown = current_time;
    }
    else if(newTime &lt; 1034*bar_time/1500) {
        flopToast = instance_create(x, y, obj_flopToast);
        flopToast.direction = point_direction(x, y, mouse_x, mouse_y);
        flopToast.image_angle = point_direction(x, y, mouse_x, mouse_y);
        spd = 10;
        
        dist = sqrt( (x - mouse_x)*(x - mouse_x) + (y - mouse_y)*(y - mouse_y) );
        dx = (x - mouse_x) / dist;
        dy = (y - mouse_y) / dist;
        flopToast.vsp = (-spd * dy);
        flopToast.hsp = (-spd * dx);
    }
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>obj_toaster</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Basic Player Movement
//Get the player's movement input
key_right = keyboard_check(ord("D"));
key_left = -keyboard_check(ord("A"));
key_jump = keyboard_check_pressed(vk_space);

//React to inputs

move = key_left + key_right;

image_speed =  abs(move) * .35;
if(move &gt; 0){
    imagestart = 8;
    imageend = 23;
}else if(move &lt; 0){
    imagestart = 24;
    imageend = 39;
}

if(afterLaunch == 1) {
    hsp = .5 * move * moveSpeed;
}
if(vsp &lt; 10) {
    vsp += grav * global.deltaT;
}

//Player can only jump while on a wall
if(place_meeting(x, y + 1, obj_wall)) {
    image_angle = 0;
    afterLaunch = 1;
    vsp = key_jump * -jumpSpeed;
    if(move != last_move){
        audio_stop_all();
        if(move != 0){
            audio_play_sound(walk, 1, true);
        }
    }
}else{
    image_index = 0;
    audio_stop_all();
}

//get movement speeds in new time space
var dvx = hsp * global.deltaT
var dvy = vsp * global.deltaT

//If there is a wall/block to the right/left and player is moving in that direction,
//move as far in the direction of the wall as possible.
if(place_meeting(x + dvx, y, obj_wall)) {
    while(!place_meeting(x + sign(dvx), y, obj_wall)) {
        x += sign(dvx);
    }
    hsp = -.5 * hsp;
    dvx = -.5 * dvx;
}
x += dvx;

//if there is a wall beneath/above player and player is moving in that direction,
//move as far in the direction of the wall as possible.
if(place_meeting(x, y + dvy, obj_wall)) {
    while(!place_meeting(x, y + sign(dvy), obj_wall)) {
        y += sign(dvy);
    }
    if(sign(vsp) == -1){
        vsp = -.5 * vsp;
        dvy = -.5 * dvy;
    }else{
        vsp = 0;
        dvy = 0;
    }
}
y += dvy;

image_index = max(imagestart, image_index mod imageend);

last_move = move;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_enemy_deathtouch">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>instance_create(0, 0, obj_gameOverFade);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_roomEnd">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(!instance_exists(obj_fadeOut)) {
    instance_create(0,0,obj_fadeOut);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>instance_create(0, 0, obj_gameOverFade);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw Object and Slider Element
if(heat &gt; 0){
    self.image_blend = make_colour_rgb(255, 255 - heat * 10, 255 - heat * 10);
}else{
    self.image_blend = c_white;
}
draw_self()

if(in_slow_motion){
    draw_sprite(spr_bar, 0, barX, barY)
    
    draw_sprite(spr_slider_element, 0, 
                    barX + 
                    time_toasting * sprite_bar_width / time_toasting_max - 
                    sprite_element_size / 2,
                    barY + sprite_bar_height - 10 +
                    sprite_indicator_size - 10);
    
    draw_sprite(spr_bar_location_indicator, 0, 
                    barX + 
                    time_toasting * sprite_bar_width / time_toasting_max - 
                    sprite_indicator_size / 2,
                    barY + sprite_bar_height - 19);
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
